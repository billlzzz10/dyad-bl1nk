# สถาปัตยกรรมของ Dyad

เอกสารนี้อธิบายภาพรวมการทำงานของแอปพลิเคชันเดสก์ท็อป Dyad หากมีส่วนใดที่ล้าสมัย สามารถเสนอการเปลี่ยนแปลงผ่าน Pull Request ได้เลยครับ

## ภาพรวม

Dyad เป็นแอปพลิเคชัน Electron ที่เป็นทางเลือกแบบโอเพนซอร์สและทำงานบนเครื่อง (local) แทนที่เครื่องมือสร้างแอป AI อื่นๆ เช่น Lovable, v0, และ Bolt แม้ว่ารายละเอียดเกี่ยวกับโครงสร้างของเครื่องมือสร้างแอป AI อื่นๆ จะไม่มีการเปิดเผยต่อสาธารณะ แต่ก็มีข้อมูลบางอย่างที่หาได้ เช่น [system prompts](https://github.com/x1xhlol/system-prompts-and-models-of-ai-tools)

## สถาปัตยกรรมของ Electron

สำหรับผู้ที่ไม่คุ้นเคยกับแอปพลิเคชัน Electron มันคล้ายกับแอปพลิเคชัน JavaScript แบบ full-stack ที่มีฝั่ง client-side เรียกว่า **renderer process** ซึ่งทำหน้าที่รันโค้ด UI เช่น React และมี Node.js process ที่เรียกว่า **main process** ซึ่งเปรียบได้กับฝั่ง server-side ของแอป full-stack โดย main process จะมีสิทธิ์เข้าถึงระบบไฟล์และทรัพยากรอื่นๆ ของระบบ ในขณะที่ renderer process จะทำงานใน sandbox ที่จำกัดสิทธิ์ Renderer process สามารถสื่อสารกับ main process โดยใช้ **IPC (Inter-process communication)** ซึ่งคล้ายกับการที่เบราว์เซอร์สื่อสารกับเซิร์ฟเวอร์โดยใช้ HTTP requests

## วงจรของหนึ่งคำขอ

เวิร์กโฟลว์หลักของ Dyad คือผู้ใช้ส่ง prompt ไปยัง AI ซึ่งจะแก้ไขโค้ดและแสดงผลในหน้าพรีวิว เราจะมาดูทีละขั้นตอน:

1.  **การสร้างคำขอไปยัง LLM** - คำขอที่ Dyad ส่งไปยัง LLM นั้นมีมากกว่าแค่ prompt (อินพุตของผู้ใช้) โดยปกติจะรวมโค้ดเบสทั้งหมดและ [system prompt](https://github.com/dyad-sh/dyad/blob/main/src/prompts/system_prompt.ts) ที่ละเอียด ซึ่งจะสั่งให้ LLM ตอบกลับในรูปแบบ XML-like ที่เฉพาะเจาะจง (เช่น `<dyad-write path="path/to/file.ts">console.log("hi")</dyad-write>`)
2.  **การสตรีมการตอบกลับของ LLM ไปยัง UI** - การให้ฟีดแบ็กแก่ผู้ใช้เป็นสิ่งสำคัญ ไม่เช่นนั้นพวกเขาจะต้องรอนานหลายนาทีโดยไม่รู้ว่าเกิดอะไรขึ้น ดังนั้นเราจึงสตรีมการตอบกลับของ LLM และแสดงผลให้เห็น เรามี [Markdown parser](https://github.com/dyad-sh/dyad/blob/main/src/components/chat/DyadMarkdownParser.tsx) ที่ออกแบบมาเป็นพิเศษเพื่อแยกวิเคราะห์แท็ก `<dyad-*>` เหล่านี้ เช่นแท็ก `<dyad-write>` ที่แสดงก่อนหน้านี้ เพื่อให้เราสามารถแสดงผลลัพธ์ของ LLM ในรูปแบบ UI ที่สวยงามแทนที่จะเป็นข้อความ XML-like ดิบๆ
3.  **การประมวลผลการตอบกลับของ LLM** - เมื่อ LLM ตอบกลับเสร็จสิ้นและผู้ใช้ได้อนุมัติการเปลี่ยนแปลง [response processor](https://github.com/dyad-sh/dyad/blob/main/src/ipc/processors/response_processor.ts) ใน main process จะนำการเปลี่ยนแปลงเหล่านั้นไปใช้ โดยพื้นฐานแล้วแต่ละแท็ก `<dyad-*>` ที่อธิบายไว้ใน [system prompt](https://github.com/dyad-sh/dyad/blob/main/src/prompts/system_prompt.ts) จะจับคู่กับตรรกะที่เฉพาะเจาะจงใน response processor เช่น การเขียนไฟล์, การลบไฟล์, การเพิ่มแพ็กเกจ NPM ใหม่ เป็นต้น

สรุปคือ Dyad จะบอกให้ LLM รู้เกี่ยวกับเครื่องมือต่างๆ เช่น การเขียนไฟล์โดยใช้แท็ก `<dyad-*>` จากนั้น renderer process จะแสดงแท็ก Dyad เหล่านี้ใน UI ที่สวยงาม และ main process จะทำหน้าที่รันคำสั่งตามแท็ก Dyad เหล่านั้นเพื่อใช้การเปลี่ยนแปลง

## คำถามที่พบบ่อย

### ทำไมไม่ใช้ Tool Calls จริงๆ?

สิ่งหนึ่งที่อาจดูแปลกคือเราไม่ได้ใช้ความสามารถในการเรียกใช้ฟังก์ชัน/เครื่องมือ (function calling/tool calling) ของ AI จริงๆ แต่กลับใช้ синтаксис XML-like ที่จำลองการเรียกใช้เครื่องมือแทน นี่เป็นสิ่งที่ผมสังเกตได้จากการศึกษา [system prompts](https://github.com/x1xhlol/system-prompts-and-models-of-ai-tools) ของเครื่องมือสร้างแอปอื่นๆ

ผมคิดว่าเหตุผลหลักสองประการที่ใช้รูปแบบ XML-like นี้แทนการเรียกใช้เครื่องมือจริงๆ คือ:

1.  คุณสามารถเรียกใช้เครื่องมือหลายอย่างได้พร้อมกัน แม้ว่าบางโมเดลจะอนุญาตให้มีการเรียกแบบขนาน ([parallel calls](https://platform.openai.com/docs/guides/function-calling/parallel-function-calling#parallel-function-calling)) แต่หลายโมเดลก็ไม่รองรับ
2.  มี [หลักฐาน](https://aider.chat/2024/08/14/code-in-json.html) ว่าการบังคับให้ LLM ส่งคืนโค้ดในรูปแบบ JSON (ซึ่งโดยพื้นฐานแล้วคือสิ่งที่ tool calling จะทำในที่นี้) ส่งผลเสียต่อคุณภาพ

อย่างไรก็ตาม AI editor หลายตัวก็พึ่งพา tool calling อย่างมาก และนี่เป็นสิ่งที่เรากำลังประเมินอยู่ โดยเฉพาะอย่างยิ่งกับการรองรับ MCP ที่กำลังจะมาถึง

### ทำไม Dyad ถึงไม่เป็น Agentic มากกว่านี้?

ระบบอื่นๆ หลายระบบ (เช่น Cursor) มีความเป็น agentic มากกว่า Dyad ตัวอย่างเช่น พวกเขาจะเรียกใช้เครื่องมือหลายอย่างและทำสิ่งต่างๆ เช่น สร้างแผน, ใช้เครื่องมือบรรทัดคำสั่งเพื่อค้นหาในโค้ดเบส, รัน linter และ test และแก้ไขโค้ดโดยอัตโนมัติตามผลลัพธ์เหล่านั้น

ในทางกลับกัน Dyad มี agentic loop ที่ค่อนข้างง่าย เราจะแก้ไขข้อผิดพลาดของ TypeScript compiler หากเปิดใช้งาน Auto-fix problems แต่โดยปกติแล้วจะเป็นการส่งคำขอเพียงครั้งเดียวไปยัง AI

ปัญหาที่ใหญ่ที่สุดของเวิร์กโฟลว์ agentic ที่ซับซ้อนคืออาจมีค่าใช้จ่ายสูงมากอย่างรวดเร็ว! ไม่ใช่เรื่องแปลกที่จะเห็นผู้ใช้รายงานว่าใช้เงินไปหลายดอลลาร์กับคำขอเพียงครั้งเดียว เพราะเบื้องหลังคำขอของผู้ใช้เพียงครั้งเดียวนั้นกลายเป็นการส่งคำขอไปยัง LLM หลายสิบครั้ง เพื่อให้ Dyad มีค่าใช้จ่ายที่คุ้มค่าที่สุดเท่าที่จะเป็นไปได้ เราจึงหลีกเลี่ยงเวิร์กโฟลว์ agentic ที่ซับซ้อน อย่างน้อยก็จนกว่าค่าใช้จ่ายของ LLM จะถูกลงกว่านี้

### ทำไม Dyad ถึงส่งโค้ดเบสทั้งหมดไปกับทุกคำขอของ AI?

การส่ง context ที่ถูกต้องไปยัง AI ได้รับการเน้นย้ำว่ามีความสำคัญอย่างมาก จนกระทั่งคำว่า ["context engineering"](https://www.philschmid.de/context-engineering) กลายเป็นที่นิยมในขณะนี้

การส่งโค้ดเบสทั้งหมดเป็นวิธีที่ง่ายที่สุดและค่อนข้างมีประสิทธิภาพสำหรับโค้ดเบสขนาดเล็ก อีกวิธีหนึ่งคือให้ผู้ใช้เลือกส่วนของโค้ดเบสที่จะใช้เป็น context อย่างชัดเจน ซึ่งสามารถทำได้ผ่านฟีเจอร์ [select component](https://www.dyad.sh/docs/releases/0.8.0) หรือ [manual context management](https://www.dyad.sh/docs/guides/large-apps#manual-context-management)

อย่างไรก็ตาม ทั้งสองวิธีนี้ต้องการให้ผู้ใช้เลือกไฟล์ที่ถูกต้องด้วยตนเองซึ่งไม่สะดวกเสมอไป ฟีเจอร์ [Smart Context](https://www.dyad.sh/docs/guides/ai-models/pro-modes#smart-context) ของ Dyad โดยพื้นฐานแล้วจะใช้โมเดลขนาดเล็กเพื่อกรองไฟล์ที่สำคัญที่สุดในแชทที่กำหนด อย่างไรก็ตาม เรากำลังทดลองแนวทางใหม่ๆ ในการเลือก context อย่างต่อเนื่อง เนื่องจากเป็นปัญหาที่ค่อนข้างยาก

แนวทางหนึ่งที่เราไม่ใช้คือสไตล์ agentic ที่เหมือนกับที่ Claude Code และ Cursor ทำ ซึ่งจะค้นหาและนำทางผ่านโค้ดเบสซ้ำๆ โดยใช้ tool calls เหตุผลหลักที่เราไม่ทำเช่นนี้คือเรื่องค่าใช้จ่าย (ดูคำถามด้านบน: [ทำไม Dyad ถึงไม่เป็น Agentic มากกว่านี้](#why-isnt-dyad-more-agentic))